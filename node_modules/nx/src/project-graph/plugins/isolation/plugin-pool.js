"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.loadRemoteNxPlugin = loadRemoteNxPlugin;
const child_process_1 = require("child_process");
const net_1 = require("net");
const path = require("path");
// TODO (@AgentEnder): After scoped verbose logging is implemented, re-add verbose logs here.
// import { logger } from '../../utils/logger';
const socket_utils_1 = require("../../../daemon/socket-utils");
const consume_messages_from_socket_1 = require("../../../utils/consume-messages-from-socket");
const installation_directory_1 = require("../../../utils/installation-directory");
const resolve_plugin_1 = require("../resolve-plugin");
const messaging_1 = require("./messaging");
const cleanupFunctions = new Set();
const pluginNames = new Map();
const PLUGIN_TIMEOUT_HINT_TEXT = 'As a last resort, you can set NX_PLUGIN_NO_TIMEOUTS=true to bypass this timeout.';
const MINUTES = 10;
const MAX_MESSAGE_WAIT = process.env.NX_PLUGIN_NO_TIMEOUTS === 'true'
    ? // Registering a timeout prevents the process from exiting
        // if the call to a plugin happens to be the only thing
        // keeping the process alive. As such, even if timeouts are disabled
        // we need to register one. 2147483647 is the max timeout
        // that Node.js allows, and is equivalent to 24.8 days....
        // This does mean that the NX_PLUGIN_NO_TIMEOUTS env var
        // would still timeout after 24.8 days, but that seems
        // like a reasonable compromise.
        2147483647
    : 1000 * 60 * MINUTES; // 10 minutes
const nxPluginWorkerCache = (global['nxPluginWorkerCache'] ??= new Map());
async function loadRemoteNxPlugin(plugin, root, index) {
    const cacheKey = JSON.stringify({ plugin, root });
    if (nxPluginWorkerCache.has(cacheKey)) {
        return [nxPluginWorkerCache.get(cacheKey), () => { }];
    }
    const moduleName = typeof plugin === 'string' ? plugin : plugin.plugin;
    const { name, pluginPath, shouldRegisterTSTranspiler } = await (0, resolve_plugin_1.resolveNxPlugin)(moduleName, root, (0, installation_directory_1.getNxRequirePaths)(root));
    const { worker, socket } = await startPluginWorker(name);
    // Register plugin worker as a subprocess of the main CLI
    // This allows metrics collection when the daemon is not used
    // Fire-and-forget to avoid blocking the loading of the plugin
    if (worker.pid) {
        (async () => {
            try {
                const { isOnDaemon } = await Promise.resolve().then(() => require('../../../daemon/is-on-daemon'));
                /**
                 * We can only register the plugin worker as a subprocess of the main CLI
                 * when the daemon is not used. Additionally, we can't explcitly register
                 * the plugin worker as a subprocess of the daemon, because when on the
                 * daemon, we'd get a different instance of the process metrics service.
                 */
                if (!isOnDaemon()) {
                    const { getProcessMetricsService } = await Promise.resolve().then(() => require('../../../tasks-runner/process-metrics-service'));
                    getProcessMetricsService().registerMainCliSubprocess(worker.pid, `${name}${index !== undefined ? ` (${index})` : ''}`);
                }
            }
            catch {
                // Silently ignore - metrics collection is optional
            }
        })();
    }
    const pendingPromises = new Map();
    const exitHandler = createWorkerExitHandler(worker, pendingPromises);
    const cleanupFunction = () => {
        worker.off('exit', exitHandler);
        // Unpipe streams to prevent hanging processes and release references
        if (worker.stdout) {
            worker.stdout.unpipe(process.stdout);
            worker.stdout.destroy();
        }
        if (worker.stderr) {
            worker.stderr.unpipe(process.stderr);
            worker.stderr.destroy();
        }
        socket.destroy();
        nxPluginWorkerCache.delete(cacheKey);
    };
    cleanupFunctions.add(cleanupFunction);
    const pluginPromise = new Promise((res, rej) => {
        (0, messaging_1.sendMessageOverSocket)(socket, {
            type: 'load',
            payload: { plugin, root, name, pluginPath, shouldRegisterTSTranspiler },
        });
        // logger.verbose(`[plugin-worker] started worker: ${worker.pid}`);
        const loadTimeout = setTimeout(() => {
            rej(new Error(`Loading "${typeof plugin === 'string' ? plugin : plugin.plugin}" timed out after ${MINUTES} minutes. ${PLUGIN_TIMEOUT_HINT_TEXT}`));
        }, MAX_MESSAGE_WAIT);
        socket.on('data', (0, consume_messages_from_socket_1.consumeMessagesFromSocket)(createWorkerHandler(worker, pendingPromises, (val) => {
            if (loadTimeout)
                clearTimeout(loadTimeout);
            res(val);
        }, rej, socket)));
        worker.on('exit', exitHandler);
    });
    nxPluginWorkerCache.set(cacheKey, pluginPromise);
    return [pluginPromise, cleanupFunction];
}
/**
 * Creates a message handler for the given worker.
 * @param worker Instance of plugin-worker
 * @param pending Set of pending promises
 * @param onload Resolver for RemotePlugin promise
 * @param onloadError Rejecter for RemotePlugin promise
 * @returns Function to handle messages from the worker
 */
function createWorkerHandler(worker, pending, onload, onloadError, socket) {
    let pluginName;
    let txId = 0;
    return function (raw) {
        const message = JSON.parse(raw);
        if (!(0, messaging_1.isPluginWorkerResult)(message)) {
            return;
        }
        return (0, messaging_1.consumeMessage)(socket, message, {
            'load-result': (result) => {
                if (result.success) {
                    const { name, createNodesPattern, include, exclude } = result;
                    pluginName = name;
                    pluginNames.set(worker, pluginName);
                    onload({
                        name,
                        include,
                        exclude,
                        createNodes: createNodesPattern
                            ? [
                                createNodesPattern,
                                (configFiles, ctx) => {
                                    const tx = pluginName + worker.pid + ':createNodes:' + txId++;
                                    return registerPendingPromise(tx, pending, () => {
                                        (0, messaging_1.sendMessageOverSocket)(socket, {
                                            type: 'createNodes',
                                            payload: { configFiles, context: ctx, tx },
                                        });
                                    }, {
                                        plugin: pluginName,
                                        operation: 'createNodes',
                                    });
                                },
                            ]
                            : undefined,
                        createDependencies: result.hasCreateDependencies
                            ? (ctx) => {
                                const tx = pluginName + worker.pid + ':createDependencies:' + txId++;
                                return registerPendingPromise(tx, pending, () => {
                                    (0, messaging_1.sendMessageOverSocket)(socket, {
                                        type: 'createDependencies',
                                        payload: { context: ctx, tx },
                                    });
                                }, {
                                    plugin: pluginName,
                                    operation: 'createDependencies',
                                });
                            }
                            : undefined,
                        createMetadata: result.hasCreateMetadata
                            ? (graph, ctx) => {
                                const tx = pluginName + worker.pid + ':createMetadata:' + txId++;
                                return registerPendingPromise(tx, pending, () => {
                                    (0, messaging_1.sendMessageOverSocket)(socket, {
                                        type: 'createMetadata',
                                        payload: { graph, context: ctx, tx },
                                    });
                                }, {
                                    plugin: pluginName,
                                    operation: 'createMetadata',
                                });
                            }
                            : undefined,
                        preTasksExecution: result.hasPreTasksExecution
                            ? (context) => {
                                const tx = pluginName + worker.pid + ':preTasksExecution:' + txId++;
                                return registerPendingPromise(tx, pending, () => {
                                    (0, messaging_1.sendMessageOverSocket)(socket, {
                                        type: 'preTasksExecution',
                                        payload: { tx, context },
                                    });
                                }, {
                                    plugin: pluginName,
                                    operation: 'preTasksExecution',
                                });
                            }
                            : undefined,
                        postTasksExecution: result.hasPostTasksExecution
                            ? (context) => {
                                const tx = pluginName + worker.pid + ':postTasksExecution:' + txId++;
                                return registerPendingPromise(tx, pending, () => {
                                    (0, messaging_1.sendMessageOverSocket)(socket, {
                                        type: 'postTasksExecution',
                                        payload: { tx, context },
                                    });
                                }, {
                                    plugin: pluginName,
                                    operation: 'postTasksExecution',
                                });
                            }
                            : undefined,
                    });
                }
                else if (result.success === false) {
                    onloadError(result.error);
                }
            },
            createDependenciesResult: ({ tx, ...result }) => {
                const { resolver, rejector } = getPendingPromise(tx, pending);
                if (result.success) {
                    resolver(result.dependencies);
                }
                else if (result.success === false) {
                    rejector(result.error);
                }
            },
            createNodesResult: ({ tx, ...result }) => {
                const { resolver, rejector } = getPendingPromise(tx, pending);
                if (result.success) {
                    resolver(result.result);
                }
                else if (result.success === false) {
                    rejector(result.error);
                }
            },
            createMetadataResult: ({ tx, ...result }) => {
                const { resolver, rejector } = getPendingPromise(tx, pending);
                if (result.success) {
                    resolver(result.metadata);
                }
                else if (result.success === false) {
                    rejector(result.error);
                }
            },
            preTasksExecutionResult: ({ tx, ...result }) => {
                const { resolver, rejector } = getPendingPromise(tx, pending);
                if (result.success) {
                    resolver(result.mutations);
                }
                else if (result.success === false) {
                    rejector(result.error);
                }
            },
            postTasksExecutionResult: ({ tx, ...result }) => {
                const { resolver, rejector } = getPendingPromise(tx, pending);
                if (result.success) {
                    resolver();
                }
                else if (result.success === false) {
                    rejector(result.error);
                }
            },
        });
    };
}
function createWorkerExitHandler(worker, pendingPromises) {
    return () => {
        // Clean up piped streams when worker exits to prevent hanging
        if (worker.stdout) {
            worker.stdout.unpipe(process.stdout);
        }
        if (worker.stderr) {
            worker.stderr.unpipe(process.stderr);
        }
        for (const [_, pendingPromise] of pendingPromises) {
            pendingPromise.rejector(new Error(`Plugin worker ${pluginNames.get(worker) ?? worker.pid} exited unexpectedly with code ${worker.exitCode}`));
        }
    };
}
function getPendingPromise(tx, pending) {
    const pendingPromise = pending.get(tx);
    if (!pendingPromise) {
        throw new Error(`No pending promise found for transaction "${tx}". This may indicate a bug in the plugin pool. Currently pending promises:\n` +
            Array.from(pending.keys())
                .map((t) => `  -  ${t}`)
                .join('\n'));
    }
    const { rejector, resolver } = pendingPromise;
    return {
        rejector,
        resolver,
    };
}
function registerPendingPromise(tx, pending, callback, context) {
    let resolver, rejector, timeout;
    const promise = new Promise((res, rej) => {
        rejector = rej;
        resolver = res;
        timeout = setTimeout(() => {
            rej(new Error(`${context.plugin} timed out after ${MINUTES} minutes during ${context.operation}. ${PLUGIN_TIMEOUT_HINT_TEXT}`));
        }, MAX_MESSAGE_WAIT);
        callback();
    }).finally(() => {
        pending.delete(tx);
        if (timeout)
            clearTimeout(timeout);
    });
    pending.set(tx, {
        promise,
        resolver,
        rejector,
    });
    return promise;
}
global.nxPluginWorkerCount ??= 0;
async function startPluginWorker(name) {
    // this should only really be true when running unit tests within
    // the Nx repo. We still need to start the worker in this case,
    // but its typescript.
    const isWorkerTypescript = path.extname(__filename) === '.ts';
    const workerPath = path.join(__dirname, 'plugin-worker');
    const env = {
        ...process.env,
        ...(isWorkerTypescript
            ? {
                // Ensures that the worker uses the same tsconfig as the main process
                TS_NODE_PROJECT: path.join(__dirname, '../../../../tsconfig.lib.json'),
            }
            : {}),
    };
    const ipcPath = (0, socket_utils_1.getPluginOsSocketPath)([process.pid, global.nxPluginWorkerCount++, performance.now()].join('-'));
    const worker = (0, child_process_1.spawn)(process.execPath, [
        ...(isWorkerTypescript ? ['--require', 'ts-node/register'] : []),
        workerPath,
        ipcPath,
        name,
    ], {
        stdio: ['ignore', 'pipe', 'pipe'],
        env,
        detached: true,
        shell: false,
        windowsHide: true,
    });
    // To make debugging easier and allow plugins to communicate things
    // like performance metrics, we pipe the stdout/stderr of the worker
    // to the main process.
    // This adds one listener per plugin to a few events on process.stdout/stderr,
    // so we need to increase the max listener count to avoid warnings.
    //
    // We originally used `inherit` for stdio, but that caused issues with
    // some environments where the terminal was left in an inconsistent state
    // that prevented `↑`/`↓` arrow keys from working correctly after Nx finished execution.
    // Instead, they would print things like `^[[A`/`^[[B` to the terminal.
    const stdoutMaxListeners = process.stdout.getMaxListeners();
    const stderrMaxListeners = process.stderr.getMaxListeners();
    if (stdoutMaxListeners !== 0) {
        process.stdout.setMaxListeners(stdoutMaxListeners + 1);
    }
    if (stderrMaxListeners !== 0) {
        process.stderr.setMaxListeners(stderrMaxListeners + 1);
    }
    worker.stdout.pipe(process.stdout);
    worker.stderr.pipe(process.stderr);
    // Unref the worker process so it doesn't prevent the parent from exiting.
    // IMPORTANT: We must also unref the stdout/stderr streams. When streams are
    // piped, they maintain internal references in Node's event loop. Without
    // unreferencing them, the parent process will wait for the worker to exit
    // even after worker.unref() is called. This causes e2e tests to hang on CI
    // where test frameworks wait for all handles to be released.
    //
    // Although TypeScript types these as Readable/Writable, they are actually
    // net.Socket instances at runtime. Node.js internally creates sockets for
    // stdio pipes (see lib/internal/child_process.js createSocket function).
    // Socket.unref() allows the event loop to exit if these are the only handles.
    worker.unref();
    if (worker.stdout instanceof net_1.Socket) {
        worker.stdout.unref();
    }
    else {
        throw new Error(`Expected worker.stdout to be an instance of Socket, but got ${getTypeName(worker.stdout)}`);
    }
    if (worker.stderr instanceof net_1.Socket) {
        worker.stderr.unref();
    }
    else {
        throw new Error(`Expected worker.stderr to be an instance of Socket, but got ${getTypeName(worker.stderr)}`);
    }
    let attempts = 0;
    return new Promise((resolve, reject) => {
        const id = setInterval(async () => {
            const socket = await isServerAvailable(ipcPath);
            if (socket) {
                socket.unref();
                clearInterval(id);
                resolve({
                    worker,
                    socket,
                });
            }
            else if (attempts > 10000) {
                // daemon fails to start, the process probably exited
                // we print the logs and exit the client
                reject('Failed to start plugin worker.');
            }
            else {
                attempts++;
            }
        }, 10);
    });
}
function isServerAvailable(ipcPath) {
    return new Promise((resolve) => {
        try {
            const socket = (0, net_1.connect)(ipcPath, () => {
                resolve(socket);
            });
            socket.once('error', () => {
                resolve(false);
            });
        }
        catch (err) {
            resolve(false);
        }
    });
}
function getTypeName(u) {
    if (u === null)
        return 'null';
    if (u === undefined)
        return 'undefined';
    if (typeof u !== 'object')
        return typeof u;
    if (Array.isArray(u)) {
        const innerTypes = u.map((el) => getTypeName(el));
        return `Array<${Array.from(new Set(innerTypes)).join('|')}>`;
    }
    return u.constructor?.name ?? 'unknown object';
}
